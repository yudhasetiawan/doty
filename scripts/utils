#!/usr/bin/env sh

set -e

# Use colors, but only if connected to a terminal
# and that terminal supports them.

# The [ -t 1 ] check only works when the function is not called from
# a subshell (like in `$(...)` or `(...)`, so this hack redefines the
# function at the top level to always return false when stdout is not
# a tty.
if [ -t 1 ]; then
  is_tty() {
    true
  }
else
  is_tty() {
    false
  }
fi

# Adapted from code and information by Anton Kochkov (@XVilka)
# Source: https://gist.github.com/XVilka/8346728
supports_truecolor() {
    case "$COLORTERM" in
    truecolor | 24bit) return 0 ;;
    esac

    case "$TERM" in
    iterm | \
        tmux-truecolor | \
        linux-truecolor | \
        xterm-truecolor | \
        screen-truecolor) return 0 ;;
    esac

    return 1
}

# This function uses the logic from supports-hyperlinks[1][2], which is
# made by Kat Marchán (@zkat) and licensed under the Apache License 2.0.
# [1] https://github.com/zkat/supports-hyperlinks
# [2] https://crates.io/crates/supports-hyperlinks
#
# Copyright (c) 2021 Kat Marchán
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
supports_hyperlinks() {
    # $FORCE_HYPERLINK must be set and be non-zero (this acts as a logic bypass)
    if [ -n "$FORCE_HYPERLINK" ]; then
        [ "$FORCE_HYPERLINK" != 0 ]
        return $?
    fi

    # If stdout is not a tty, it doesn't support hyperlinks
    is_tty || return 1

    # DomTerm terminal emulator (domterm.org)
    if [ -n "$DOMTERM" ]; then
        return 0
    fi

    # VTE-based terminals above v0.50 (Gnome Terminal, Guake, ROXTerm, etc)
    if [ -n "$VTE_VERSION" ]; then
        [ $VTE_VERSION -ge 5000 ]
        return $?
    fi

    # If $TERM_PROGRAM is set, these terminals support hyperlinks
    case "$TERM_PROGRAM" in
    Hyper | iTerm.app | terminology | WezTerm) return 0 ;;
    esac

    # kitty supports hyperlinks
    if [ "$TERM" = xterm-kitty ]; then
        return 0
    fi

    # Windows Terminal also supports hyperlinks
    if [ -n "$WT_SESSION" ]; then
        return 0
    fi

    # Konsole supports hyperlinks, but it's an opt-in setting that can't be detected
    # https://github.com/ohmyzsh/ohmyzsh/issues/10964
    # if [ -n "$KONSOLE_VERSION" ]; then
    #   return 0
    # fi

    return 1
}

# Adapted from code and information by Anton Kochkov (@XVilka)
# Source: https://gist.github.com/XVilka/8346728
supports_truecolor() {
    case "$COLORTERM" in
    truecolor | 24bit) return 0 ;;
    esac

    case "$TERM" in
    iterm | \
        tmux-truecolor | \
        linux-truecolor | \
        xterm-truecolor | \
        screen-truecolor) return 0 ;;
    esac

    return 1
}

setup_color() {
    # Only use colors if connected to a terminal
    if ! is_tty; then
        FMT_RAINBOW=""
        FMT_RED=""
        FMT_GREEN=""
        FMT_YELLOW=""
        FMT_BLUE=""
        FMT_BOLD=""
        FMT_RESET=""
        return
    fi

    if supports_truecolor; then
        FMT_RAINBOW="
      $(printf '\033[38;2;255;0;0m')
      $(printf '\033[38;2;255;97;0m')
      $(printf '\033[38;2;247;255;0m')
      $(printf '\033[38;2;0;255;30m')
      $(printf '\033[38;2;77;0;255m')
      $(printf '\033[38;2;168;0;255m')
      $(printf '\033[38;2;245;0;172m')
    "
        FMT_PURPLE=$(printf '\033[38;2;245;0;172m')
    else
        FMT_RAINBOW="
      $(printf '\033[38;5;196m')
      $(printf '\033[38;5;202m')
      $(printf '\033[38;5;226m')
      $(printf '\033[38;5;082m')
      $(printf '\033[38;5;021m')
      $(printf '\033[38;5;093m')
      $(printf '\033[38;5;163m')
    "
        FMT_PURPLE=$(printf '\033[38;5;163m')
    fi

    FMT_RED=$(printf '\033[31m')
    FMT_GREEN=$(printf '\033[32m')
    FMT_YELLOW=$(printf '\033[33m')
    FMT_BLUE=$(printf '\033[34m')
    FMT_BOLD=$(printf '\033[1m')
    FMT_RESET=$(printf '\033[0m')
}

command_exists() {
    command -v "$@" >/dev/null 2>&1
}

user_can_sudo() {
    # Check if sudo is installed
    command_exists sudo || return 1
    # Termux can't run sudo, so we can detect it and exit the function early.
    case "$PREFIX" in
    *com.termux*) return 1 ;;
    esac
    # The following command has 3 parts:
    #
    # 1. Run `sudo` with `-v`. Does the following:
    #    • with privilege: asks for a password immediately.
    #    • without privilege: exits with error code 1 and prints the message:
    #      Sorry, user <username> may not run sudo on <hostname>
    #
    # 2. Pass `-n` to `sudo` to tell it to not ask for a password. If the
    #    password is not required, the command will finish with exit code 0.
    #    If one is required, sudo will exit with error code 1 and print the
    #    message:
    #    sudo: a password is required
    #
    # 3. Check for the words "may not run sudo" in the output to really tell
    #    whether the user has privileges or not. For that we have to make sure
    #    to run `sudo` in the default locale (with `LANG=`) so that the message
    #    stays consistent regardless of the user's locale.
    #
    ! LANG= sudo -n -v 2>&1 | grep -q "may not run sudo"
}

prompt() {
    printf '%s%s%s' "${FMT_YELLOW}" "$1" "${FMT_RESET}" >&2
    read -p " ${FMT_BOLD}[y/N]${FMT_RESET} " a
    if [[ $a == "y" || $a == "Y" ]]; then
        return 0
    fi
    return 1
}

underline() {
    is_tty && printf '\033[4m%s\033[24m' "$*" || printf '%s' "$*"
}

link() {
    # $1: text, $2: url, $3: fallback mode
    if supports_hyperlinks; then
        printf '\033]8;;%s\033\\%s\033]8;;\033\\' "$2" "$1"
        return
    fi

    case "$3" in
    --text) printf '%s\n' "$1" ;;
    --url | *) underline "$2" ;;
    esac
}

# shellcheck disable=SC2016 # backtick in single-quote
fmt_code() {
    is_tty && printf '\033[2m%s\033[22m' "$*" || printf '`%s`' "$*"
}

codeblock() {
    fmt_code $* >&2
    printf '\n' >&2
}

success() {
    printf '%s%s%s\n' "${FMT_BOLD}${FMT_GREEN}" "$*" "$FMT_RESET" >&2
}

info() {
    printf '%s%s%s\n' "${FMT_BOLD}${FMT_BLUE}" "$*" "$FMT_RESET" >&2
}

warning() {
    printf '%s%s%s\n' "${FMT_BOLD}${FMT_YELLOW}" "$*" "$FMT_RESET" >&2
}

error() {
    printf '%s%s%s\n' "${FMT_BOLD}${FMT_RED}" "$*" "$FMT_RESET" >&2
}

# Header logging
header() {
    text=${@}
    total_chars=${#text}

    if [ "$total_chars" -gt 80 ]; then
        total_chars=80
    fi

    printf "$(tput setaf 7)%s$(tput sgr0)\n" "$text" >&2
    for ((i = 1; i <= $total_chars; i++)); do
        printf "$(tput setaf 237)-$(tput sgr0)" >&2
    done
    printf '\n'  >&2
}

# # Success logging
# function success() {
#     printf "$(tput setaf 64)✓ %s$(tput sgr0)\n" "$@"
# }

# # Info logging
# function info() {
#     printf "$(tput setaf 27)INFO: %s$(tput sgr0)\n" "$@"
# }

# # Warning logging
# function warning() {
#     printf "$(tput setaf 136)WARN: %s$(tput sgr0)\n" "$@"
# }

# # Error logging
# function error() {
#     printf "$(tput setaf 1)ERR: %s$(tput sgr0)\n" "$@"
# }

# function echo_green() {
#     printf "$(tput setaf 64)%s$(tput sgr0)\n" "$@"
# }

# function echo_blue() {
#     printf "$(tput setaf 27)%s$(tput sgr0)\n" "$@"
# }

# function echo_yellow() {
#     printf "$(tput setaf 136)%s$(tput sgr0)\n" "$@"
# }

# function echo_red() {
#     printf "$(tput setaf 1)%s$(tput sgr0)\n" "$@"
# }

# function separator() {
#     for ((i = 1; i <= 80; i++)); do
#         printf "$(tput setaf 237)-$(tput sgr0)"
#     done
#     echo
# }

# Test whether we're in a git repo
is_git_repo() {
    $(git rev-parse --is-inside-work-tree &> /dev/null)
}

# Detect the OS/distribution
detect_os() {
    # Default to unknown
    OS_TYPE="unknown"

    # Check for macOS first
    if [[ "$OSTYPE" == "darwin"* ]]; then
        OS_TYPE="macos"
        return
    fi

    # Check for Termux (Android)
    if [[ -n "$PREFIX" ]] && [[ "$PREFIX" == *com.termux* ]]; then
        OS_TYPE="termux"
        return
    fi

    # Check for various Linux distributions
    if command -v lsb_release >/dev/null 2>&1; then
        local distribution=$(lsb_release -si | tr '[:upper:]' '[:lower:]')
        case "$distribution" in
            ubuntu)
                OS_TYPE="ubuntu"
                ;;
            debian)
                OS_TYPE="debian"
                ;;
            fedora)
                OS_TYPE="fedora"
                ;;
            archlinux|arch)
                OS_TYPE="arch"
                ;;
            *)
                OS_TYPE="linux"
                ;;
        esac
        return
    fi

    # Alternative detection methods for distributions without lsb_release
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        . /etc/os-release
        local id=$(echo "$ID" | tr '[:upper:]' '[:lower:]')
        case "$id" in
            ubuntu)
                OS_TYPE="ubuntu"
                ;;
            debian)
                OS_TYPE="debian"
                ;;
            fedora)
                OS_TYPE="fedora"
                ;;
            arch)
                OS_TYPE="arch"
                ;;
            *)
                OS_TYPE="linux"
                ;;
        esac
        return
    fi

    # Fallback for other Unix-like systems
    if command -v uname >/dev/null 2>&1; then
        local uname_output=$(uname -s | tr '[:upper:]' '[:lower:]')
        case "$uname_output" in
            linux)
                OS_TYPE="linux"
                ;;
            *)
                OS_TYPE="unix"
                ;;
        esac
        return
    fi
}

setup_color
